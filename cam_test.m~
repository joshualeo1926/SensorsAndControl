close all;
clear all;
clc;

fetch_con = Fetch();
tracker = image_track(true);
depth_sensor = depth_sense(true);

target_dist = 2;
collision_threshold = 0.5
ang_pid = PID_controller(0, 3, 0, 0.5);
dst_pid = PID_controller(target_dist, 1.5, 0, 0.15);

searching_angular_speed = 0;
last_found_time = 0;
re_aquire_window = 20;

last_ang_command = 0;
last_lin_command = 0;
for i=0:2000
    
    rgb_data = fetch_con.get_rgb_image();
    [target_found, x_err, x_pixel, y_pixel] = tracker.get_error(rgb_data);
    if x_err > 0 
        re_aquire_direction = 'r';
    else
        re_aquire_direction = 'l';
    end
    if target_found
        ang_control = ang_pid.get_control(x_err);
        
        depth_data = fetch_con.get_depth_image();
        [dst, min_dist] = depth_sensor.get_distance(depth_data, x_pixel, y_pixel);
        if min_dist >= 
        if dst ~= 9999
            dst_control = min(max(dst_pid.get_control(dst), -1), 1);

            fetch_con.linear_move(-dst_control);
            fetch_con.angular_move(ang_control);
            last_ang_command = ang_control;
            last_lin_command = -dst_control;
        else
            fetch_con.linear_move(last_lin_command);
            fetch_con.angular_move(last_ang_command);
        end
        last_found_time = cputime;
        
    elseif (cputime) - last_found_time >= re_aquire_window
        fetch_con.angular_move(sign(last_ang_command)*0.35);
        fetch_con.linear_move(0);        
    else
        multip = ((re_aquire_window - min((cputime - last_found_time), re_aquire_window))/re_aquire_window)/2;
        
        'trying to recover'
        cputime
        fetch_con.linear_move(multip * last_lin_command*1.5);
        fetch_con.angular_move((1-multip) * last_ang_command*1.5);
    end
    
end
